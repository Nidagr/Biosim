# -*- encoding: utf-8 -*-
__author__ = "Nida Grønbekk and Yuliia Dzihora"
__email__ = 'nida.gronbekk@nmbu.no and yuliia.dzihora@nmbu.no'

from .fauna import Herbivore, Carnivore
from .island import Island
from .landscape import Highland, Lowland, Water, Desert
import random
import pandas as pd  # for dataframe
import matplotlib.pyplot as plt
import numpy as np
import subprocess


class BioSim:
    """
    Class BioSim contains functions to run a simulation, visualize it and save it to files, both as
    images and as movies.
    """

    def __init__(self, island_map, ini_pop, seed,
                 ymax_animals=None, cmax_animals=None, hist_specs=None,
                 img_base=None, img_fmt='png', total_years=None):
        """
        Constructor method for class BioSim. When an instance of this class is made, an object
        map representing the island will automatically be generated by make_map() function in
        Island class. self._object_map will be the reference for the island map. The animals
        specified by ini_pop will be automatically added to the island by function add_population().
        A variable _year will be initiated as 0, it will help us keep track of which year of the
        simulation we are currently in.

        :param island_map: Multi-line string specifying island geography
        :param ini_pop: List of dictionaries specifying initial population
        :param seed: Integer used as random number seed
        :param ymax_animals: Number specifying y-axis limit for graph showing animal numbers
        :param cmax_animals: Int specifying color-code limits for animal densities
        :param hist_specs: Specifications for histograms, see below
        :param img_base: String with beginning of file name for figures, including path
        :param img_fmt: String with file type for figures, e.g. 'png'
        :param total_years: If we already know total number of years that will be simulated, send
        as input in constructor.

        If ymax_animals is None, the y-axis limit should be adjusted automatically.

        If cmax_animals is None, sensible, fixed default value should be used.
        cmax_animals is an integer. It describes max value for the color bar in heat maps.

        hist_specs is a dictionary with one entry per property for which a histogram shall be shown.
        For each property, a dictionary providing the maximum value and the bin width must be
        given, e.g.,
        {'weight': {'max': 80, 'delta': 2}, 'fitness': {'max': 1.0, 'delta': 0.05}}
        Permitted properties are 'weight', 'age', 'fitness'.

        If img_base is None, no figures are written to file.
        Filenames are formed as
        '{}_{:05d}.{}'.format(img_base, img_no, img_fmt)
        where img_no are consecutive image numbers starting from 0.
        img_base should contain a path and beginning of a file name.
        """
        random.seed(seed)
        self.seed_value_input = seed

        self.island_map = island_map
        self.island = Island(island_map)
        self.island.make_map()
        self.object_map = self.island.object_map

        self.add_population(ini_pop)

        self.accesible_landscapes = [Highland, Lowland, Desert]

        self.sim_df = pd.DataFrame(data=None, index=None,
                                   columns=['Seed', 'Year of simulation', 'Herbivore',
                                            'Carnivore', 'Total animals'], dtype=None)

        self._year = 0

        # The axes we want to include when visualizing our simulation is first set to None and given
        # values later. All of the axes will be a part of self._fig
        self._fig = None
        self._txt = None

        self._ax_island_map = None
        self._ax_cnt = None
        self._ax_num_animals = None
        self.herb_line = None
        self.carn_line = None
        self._ax_fitness = None
        self._ax_age = None
        self._ax_weight = None
        self._ax_heatmap_herb = None
        self._heatmap_herb_visual = None
        self._ax_heatmap_carn = None
        self._heatmap_carn_visual = None

        self.cmax_animals = cmax_animals if cmax_animals is not None else 250

        self.ymax_animals = ymax_animals if ymax_animals is not None else 20000

        # If we already know how many years we want to simulate when making an object of BioSim
        # we can set total_years to be this value, use this in plot of num_animals.
        self.total_years = total_years if total_years is not None else 1500

        self.herb_f_hist = None
        self.carn_f_hist = None

        self.herb_a_hist = None
        self.carn_a_hist = None

        self.herb_w_hist = None
        self.carn_w_hist = None

        self._hist_specs = hist_specs if hist_specs is not None else \
            {'fitness': {'max': 1.0, 'delta': 0.1}, 'age': {'max': 40, 'delta': 2},
             'weight': {'max': 60, 'delta': 2}}

        self._img_base = img_base
        self._img_fmt = img_fmt
        self._img_counter = 0
        self._img_step = 1

        self._FFMPEG_BINARY = 'ffmpeg'
        self.movie_fmt = 'mp4'

    def set_animal_parameters(self, species, params):
        """
        Set parameters for animal classes.
        :param species: String, name of animal species
        :type species: string

        :param params: Dict with valid parameter specification for species
        :type params: dictionary

        :raises ValueError: If the string specifying the species is not Herbivore or Carnivore,
        there is no other species to change the parameters of.
        """
        if species == 'Herbivore':
            Herbivore.set_params(params)
        elif species == 'Carnivore':
            Carnivore.set_params(params)
        else:
            raise ValueError('No such species exist.')

    def set_landscape_parameters(self, landscape, params):
        """
        Set parameters for landscape class.

        :param landscape: Code letter for landscape type.
        :type landscape: string

        :param params: Dictionary with valid parameter specification for landscape.
        :type params: Dictionary

        :raises ValueError: The code letter given for the landscape type is not valid, no such
        landscape type exists.
        """
        dict = {'H': Highland, 'L': Lowland, 'D': Desert, 'W': Water}
        if landscape in dict:
            dict[landscape].set_landscape_params(params)
        else:
            raise ValueError('No such landscape exist.')

    def add_population(self, population):
        """
        Add a population to the island.

        Check if input specified location 'loc' has row and col values inside legal range.
        Then check if the cell in this location is of type Water, in that case, raise ValueError,
        no animal may be placed in Water.

        If the location is okay, proceed to add animals here. Check if the input animal is given
        arguments for age which is non-negative, if not raise ValueError. Check if weight is
        positive, otherwise raise ValueError. Then add new object of the species with the
        specified age and weight arguments to the corresponding list in the cell.

        Since we use a 2d array to store the island map, the upper left corner has coordinates
        (0, 0). The examples consider upper left corner to have coordinates (1, 1), therefore
        subtract one from the row and col coordinates to place animals correctly in our array.

        :param population: List of dictionaries specifying population
        :type population: list of dictionaries

        :raises ValueError: The location is not legal to put animals or input arguments for the
        animal does not have legal value.
        """

        for dict in population:
            (row, col) = dict['loc']
            if not 0 <= (col - 1) < len(self.object_map[0]):
                raise ValueError('Coordinate out of bands.')
            if not 0 <= (row - 1) < len(self.object_map.T[0]):
                raise ValueError('Coordinate out of bounds.')
            if type(self.object_map[row - 1, col - 1]) == Water:
                raise ValueError('Animals can not be placed in water!')
            for animal in dict['pop']:
                age = animal['age']
                weight = animal['weight']
                if age < 0:
                    raise ValueError('Age should be non-negative.')
                if weight <= 0:
                    raise ValueError('Weight must be positive.')
                if animal['species'] == 'Herbivore':
                    self.object_map[row - 1, col - 1].herbivores.append(Herbivore(age, weight))
                if animal['species'] == 'Carnivore':
                    self.object_map[row - 1, col - 1].carnivores.append(Carnivore(age, weight))

    def feeding_cycle(self):
        """
        Feeding cycle starts with the annual fodder regrowth, amount of available food
        is set to the maximum value at that specific landscape type. Animals eat in specific order:
        first herbivores and then carnivores. For each cell in the map we call the feed functions
        from class Landscape for all herbivores and carnivores in the cell.
        """

        for cell in self.island.island_iterator():
            cell.annual_f_max()

        for cell in self.island.island_iterator():
            cell.feed_herbivores()
            cell.feed_carnivores()

    def procreation_cycle(self):
        """
        Procreation cycle defines animals reproduction. Iterate through each cell in the map.
        Count number of herbivores and carnivores in cell before procreation starts. This way
        we do not count newborns when deciding if animals give birth or not. Call the procreation
        function inside the landscape file which calls a birth function for each animal of each
        species.
        """
        for cell in self.island.island_iterator():
            num_herbs = len(cell.herbivores)
            num_carns = len(cell.carnivores)
            cell.procreation(num_herbs, num_carns)

    def migrate_one_species_one_cell(self, present_animals):
        """
        This function takes in a list of animals. Call the migration function from Fauna class on
        each animal. If the animal does try to move check if the landscape type of the cell they
        want to migrate to is not of type water. If that is the case, we append the animal to the
        list incoming_herbivores or incoming_carnivores of the goal cell. Then append the animal to
        the temporary list to_be_removed in current cell. After the function is called for animals
        in the list, overwrite the list of current animals in cell to only contain the ones not to
        be removed. Hence "deletion" is executed for this cell.

        :param present_animals: A list containing animal objects of one species, herbivores or
        carnivores.
        :type present_animals: list
        """
        to_be_removed = []
        for animal in present_animals:
            return_value = animal.migration(self.island.row, self.island.col)
            if return_value is None:
                pass
            else:
                val1 = return_value[0]
                val2 = return_value[1]
                goal_cell = self.object_map[val1, val2]
                if type(goal_cell) in self.accesible_landscapes:
                    if isinstance(animal, Herbivore):
                        goal_cell.incoming_herbivores.append(animal)
                    if isinstance(animal, Carnivore):
                        goal_cell.incoming_carnivores.append(animal)
                    to_be_removed.append(animal)
        return [a for a in present_animals if a not in to_be_removed]

    def migration_cycle(self):
        """
        Iterate through the island cell by cell using the island_iterator() and call
        migrate_one_species_one_cell on each of the lists of animals in the cell. The function will
        return a list of animals that chose to stay in the cell. And neighboring cells will have new
        lists of incoming animals.

        After migration is applied to all animals of all cells, add the lists of incoming animals
        in the cell to the list of current animals in the cell. Then clear them out, so they are
        ready for next time animals should migrate.
        """
        for cell in self.island.island_iterator():
            herbs = cell.herbivores
            carns = cell.carnivores
            cell.herbivores = self.migrate_one_species_one_cell(herbs)
            cell.carnivores = self.migrate_one_species_one_cell(carns)

        for cell in self.island.island_iterator():
            cell.herbivores = cell.herbivores + cell.incoming_herbivores
            cell.carnivores = cell.carnivores + cell.incoming_carnivores
            cell.incoming_herbivores = []
            cell.incoming_carnivores = []

    def aging_cycle(self):
        """
        Update the age of each animal in each cell. Done by iterating through the cells
        in the map and calling the aging function from the Landscape class.
        Call this when one year has passed.
        """
        for cell in self.island.island_iterator():
            cell.aging()

    def loss_of_weight_cycle(self):
        """
        All animals annually loose weight by eta * weight of the animal. Iterate through each cell
        of the island and call the loss_of_weight() function in landscape file.
        """
        for cell in self.island.island_iterator():
            cell.loss_of_weight()

    def death_cycle(self):
        """
        Each animal dies with certain probability and the death_cycle function ensures that
        all animals that was supposed to die, died and was removed from the lists in each cell.
        """
        for cell in self.island.island_iterator():
            cell.death()

    @property
    def year(self):
        """Last year simulated."""
        return self._year

    @property
    def num_animals(self):
        """Total number of animals on island."""
        return sum(self.num_animals_per_species.values())

    @property
    def num_animals_per_species(self):
        """
        This function finds the number of animals per species on the island. Iterate through
        each cell of the island and update count of how many animals we have of each species.
        After we iterated through the island, return the number of animals of each species
        as a dictionary.

        :return num_animals_species: Dictionary of the form {'Herbivore': num_h, 'Carnivore': num_c}
        :rtype num_animals_species: dict
        """
        num_herbs = 0
        num_carns = 0

        for cell in self.island.island_iterator():
            num_herbs += len(cell.herbivores)
            num_carns += len(cell.carnivores)

        num_animals_species = {'Herbivore': num_herbs, 'Carnivore': num_carns}
        return num_animals_species

    def _herb_array(self):
        """
        This function creates a 2D array, where each place in the array (representing same
        place in the map) contains number of herbivores in this cell. Start by making array
        of 0's and then iterate through each cell of the island and adding number of herbivores.

        :return herb_array: 2d array of number of herbivores in each cell.
        :rtype herb_array: 2d array of int
        """
        row_length = len(self.object_map.T[0])
        col_length = len(self.object_map[0])
        herb_array = np.zeros((row_length, col_length))

        for cell in self.island.island_iterator():
            herb_array[self.island.row, self.island.col] = len(cell.herbivores)
        return herb_array

    def _carn_array(self):
        """
        This function creates a 2D array, where each place in the array (representing same
        place in the map) contains number of carnivores in this cell. Start by making array
        of 0's and then iterate through each cell of the island and adding number of carnivores.

        :return carn_array: 2d array of number of carnivores in each cell.
        :rtype carn_array: 2d array of int
        """
        row_length = len(self.object_map.T[0])
        col_length = len(self.object_map[0])
        carn_array = np.zeros((row_length, col_length))

        for cell in self.island.island_iterator():
            carn_array[self.island.row, self.island.col] = len(cell.carnivores)
        return carn_array

    def property_distribution(self):
        """
        We want to record the distribution of weight, age and fitness for the two species.
        Do this by first adding all the fitnesses, ages and weights for each species to
        empty lists. Then make a numpy histogram of the lists, giving a value for bins
        (specified by input max/input delta). This histogram function will return a list of
        length max/delta, where each spot contains number of animals with property
        (age/weight/fitness) falling in the interval of the bin.

        :return herb_fit_count: List of length max/delta with number of animals with certain fitness
        at each spot.
        :rtype herb_fit_count: list

        :return carn_fit_count: List of length max/delta with number of animals with certain fitness
        at each spot.
        :rtype carn_fit_count: list

        :return herb_age_count: List of length max/delta with number of animals with certain age
        at each spot.
        :rtype herb_age_count: list

        :return carn_age_count: List of length max/delta with number of animals with certain age
        at each spot.
        :rtype carn_age_count: list

        :return herb_weight_count: List of length max/delta with number of animals with certain
        weight at each spot.
        :rtype herb_weight_count: list

        :return carn_weight_count: List of length max/delta with number of animals with certain
        weight at each spot.
        :rtype carn_weight_count: list
        """
        herbivore_fitnesses = []
        carnivore_fitnesses = []
        herbivore_ages = []
        carnivore_ages = []
        herbivore_weights = []
        carnivore_weights = []
        for cell in self.island.island_iterator():
            for h in cell.herbivores:
                herbivore_fitnesses.append(h.get_fitness())
                herbivore_ages.append(h.get_age())
                herbivore_weights.append(h.get_weight())
            for c in cell.carnivores:
                carnivore_fitnesses.append(c.get_fitness())
                carnivore_ages.append(c.get_age())
                carnivore_weights.append(c.get_weight())

        fit_bins = int(
            (self._hist_specs['fitness']['max']) / self._hist_specs['fitness']['delta'])
        herb_fit_count, bin_edges1 = np.histogram(herbivore_fitnesses, bins=fit_bins)
        carn_fit_count, bin_edges2 = np.histogram(carnivore_fitnesses, bins=fit_bins)

        age_bins = int((self._hist_specs['age']['max']) / self._hist_specs['age']['delta'])
        herb_age_count, bin_edges3 = np.histogram(herbivore_ages, bins=age_bins)
        carn_age_count, bin_edges4 = np.histogram(carnivore_ages, bins=age_bins)

        weight_bins = int(
            (self._hist_specs['weight']['max']) / self._hist_specs['weight']['delta'])
        herb_weight_count, bin_edges5 = np.histogram(herbivore_weights, bins=weight_bins)
        carn_weight_count, bin_edges6 = np.histogram(carnivore_weights, bins=weight_bins)
        return herb_fit_count, carn_fit_count, herb_age_count, carn_age_count, herb_weight_count, \
               carn_weight_count

    def simulate(self, num_years, vis_years=1, img_years=None):
        """
        Run simulation while visualizing the result.
        :param num_years: number of years to simulate
        :param vis_years: years between visualization updates
        :param img_years: years between visualizations saved to files (default: vis_years)
        Image files will be numbered consecutively. If no input given, do not save images.

        Start by calling setup() which creates figure with empty plots. Enter while loop and
        update dataframe. Call each of the cycles/seasons on the island. Then call
        _update_everything() which updates all the plots in the visualization. If an input
        for img_years is given, and num_years is divisible by img_years, the figure will
        be saved to a file every img_years'th year of the simulation. Update self._year and
        simulation year by 1. Then add a pause to make sure we see the visualization before the next
        one is called. After the simulation we save the dataframe to a csv file.
        """
        simulation_year = 0
        self.setup()
        while simulation_year < num_years:
            sim_year = self._year + 1
            self.sim_df = self.sim_df.append({'Seed': self.seed_value_input,
                                              'Year of simulation': sim_year,
                                              'Herbivore': self.num_animals_per_species[
                                                  'Herbivore'],
                                              'Carnivore': self.num_animals_per_species[
                                                  'Carnivore'],
                                              'Total animals': self.num_animals}, ignore_index=True)
            self.feeding_cycle()
            self.procreation_cycle()
            self.migration_cycle()
            self.aging_cycle()
            self.loss_of_weight_cycle()
            self.death_cycle()

            if self._year % vis_years == 0:
                self._update_everything(self._year)

            if img_years is not None:
                if img_years % vis_years != 0:
                    raise ValueError('img_years must be multiple of vis_years')

                if self._year % img_years == 0:
                    self._save_visuals(img_years)

            self._year += 1
            simulation_year += 1
            plt.pause(1e-06)

        self.sim_df.to_csv('../data_frame')

    def _make_rgb_map(self):
        """
        This function plots the island map in the upper left corner of our figure. Code taken
        from lecture.
        """
        rgb_value = {'W': (0.0, 0.0, 1.0),
                     'L': (0.0, 0.6, 0.0),
                     'H': (0.5, 1.0, 0.5),
                     'D': (1.0, 1.0, 0.5)}

        map_rgb = [[rgb_value[column] for column in row] for row in self.island_map.splitlines()]

        self._ax_island_map.imshow(map_rgb)

        self._ax_island_map.set_xticks(range(len(map_rgb[0])))
        self._ax_island_map.set_xticklabels(range(1, 1 + len(map_rgb[0])))
        self._ax_island_map.set_yticks(range(len(map_rgb)))
        self._ax_island_map.set_yticklabels(range(1, 1 + len(map_rgb)))
        self._ax_island_map.axis('off')

    def setup(self):
        """
        Set up the figure in which we will display all of our plots for visualization purposes.
        The figure will include a map of the island in upper left corner, a counter for year since
        start of simulation, a heatmap of herbivores in upper right corner, a lineplot of number
        of animals of each species in left center. A distribution plot of fitness, age and weight in
        the bottom three spots, and a heatmap of carnivores in center right spot.
        """

        if self._fig is None:
            self._fig = plt.figure()
            self._fig.suptitle('Simulation of the Rossumøya island')
            gs = self._fig.add_gridspec(22, 22)

        if self._ax_island_map is None:
            self._ax_island_map = self._fig.add_subplot(gs[0:6, 0:6])
            self._make_rgb_map()

        if self._ax_cnt is None:
            self._ax_cnt = self._fig.add_subplot(gs[0:3, 8:14])
            self._ax_cnt.axis('off')
            template = 'Year: {:5}'
            self._txt = self._ax_cnt.text(0.5, 0.5, template.format(self._year),
                                          horizontalalignment='center',
                                          verticalalignment='center',
                                          transform=self._ax_cnt.transAxes)

        if self._ax_num_animals is None:
            self._ax_num_animals = self._fig.add_subplot(gs[8:14, 0:6])
            self._ax_num_animals.set_xlim(0, self._year + 1)
            self._ax_num_animals.set_ylim(0, self.ymax_animals)

            if self.herb_line is None:
                herb_quantity = self._ax_num_animals.plot(
                    np.arange(0, self.total_years),
                    np.full(self.total_years, np.nan), 'b-')

                self.herb_line = herb_quantity[0]

            if self.carn_line is None:
                carn_quantity = self._ax_num_animals.plot(
                    np.arange(0, self.total_years),
                    np.full(self.total_years, np.nan), 'r-')

                self.carn_line = carn_quantity[0]

        if self._ax_fitness is None:
            self._ax_fitness = self._fig.add_subplot(gs[16:, 0:6])
            bin_lims = np.arange(0, self._hist_specs['fitness']['max'],
                                 self._hist_specs['fitness']['delta'])
            self._ax_fitness.set_xlim(0, self._hist_specs['fitness']['max'])
            self._ax_fitness.set_ylim(0, self.num_animals)
            self.herb_f_hist, self.carn_f_hist = self._ax_fitness.step(bin_lims,
                                                                       np.zeros_like(bin_lims),
                                                                       'b-',
                                                                       bin_lims,
                                                                       np.zeros_like(bin_lims),
                                                                       'r-',
                                                                       where='mid')

        if self._ax_age is None:
            self._ax_age = self._fig.add_subplot(gs[16:, 8:14])

            bin_lims = np.arange(0, self._hist_specs['age']['max'],
                                 self._hist_specs['age']['delta'])
            self._ax_age.set_xlim(0, self._hist_specs['age']['max'])
            self._ax_age.set_ylim(0, self.num_animals)
            self.herb_a_hist, self.carn_a_hist = self._ax_age.step(bin_lims,
                                                                   np.zeros_like(bin_lims),
                                                                   'b-',
                                                                   bin_lims,
                                                                   np.zeros_like(bin_lims),
                                                                   'r-',
                                                                   where='mid')
        if self._ax_weight is None:
            self._ax_weight = self._fig.add_subplot(gs[16:, 16:])
            bin_lims = np.arange(0, self._hist_specs['weight']['max'],
                                 self._hist_specs['weight']['delta'])
            self._ax_weight.set_xlim(0, self._hist_specs['weight']['max'])
            self._ax_weight.set_ylim(0, self.num_animals)
            self.herb_w_hist, self.carn_w_hist = self._ax_weight.step(bin_lims,
                                                                      np.zeros_like(bin_lims),
                                                                      'b-',
                                                                      bin_lims,
                                                                      np.zeros_like(bin_lims),
                                                                      'r-',
                                                                      where='mid')

        if self._ax_heatmap_herb is None:
            self._ax_heatmap_herb = self._fig.add_subplot(gs[0:6, 16:])
            self._heatmap_herb_visual = None

        if self._ax_heatmap_carn is None:
            self._ax_heatmap_carn = self._fig.add_subplot(gs[8:14, 16:])
            self._heatmap_carn_visual = None

        subplots = [self._ax_island_map, self._ax_cnt, self._ax_num_animals, self._ax_fitness,
                    self._ax_age, self._ax_weight,
                    self._ax_heatmap_herb, self._ax_heatmap_carn]
        titles = ['Island map', '', 'Number of animals', 'Fitness distribution',
                  'Age distribution', 'Weight distribution', 'Heatmap: Herbivores',
                  'Heatmap: Carnivores']
        counter = 0
        for subplot in subplots:
            subplot.set_title(titles[counter], fontsize=8)
            subplot.tick_params(labelsize=8)
            counter += 1
        self._ax_heatmap_herb.axis('off')
        self._ax_heatmap_carn.axis('off')
        # Include legend in plots which tells us which color represents carnivores and herbivores.
        line_labels = ['Herbivores', 'Carnivores']
        self._ax_num_animals.legend(labels=line_labels, loc='upper left', frameon=False,
                                    prop={'size': 5})
        self._ax_fitness.legend(labels=line_labels, loc='upper left', frameon=False,
                                prop={'size': 5})
        self._ax_age.legend(labels=line_labels, loc='upper left', frameon=False,
                            prop={'size': 5})
        self._ax_weight.legend(labels=line_labels, loc='upper left', frameon=False,
                               prop={'size': 5})


    def _update_num_animals(self, step, num_herb, num_carn):
        """
        Everytime a new year of the simulation starts, the number of animals of each species is
        recalculated. This function updates the plot showing the number of animals.
        """
        y_herb = self.herb_line.get_ydata()
        y_herb[step] = num_herb
        self.herb_line.set_ydata(y_herb)

        y_carn = self.carn_line.get_ydata()
        y_carn[step] = num_carn
        self.carn_line.set_ydata(y_carn)

        # makes x wider
        self._ax_num_animals.set_xlim(0, self._year + 1)

    def _update_herbivore_heatmap(self, herb_array):
        """
        This function updates the heatmap of herbivores plot each time it is called. Shows the
        distribution of herbivores in the cells of the island.
        """
        if self._heatmap_herb_visual is not None:
            self._heatmap_herb_visual.set_data(herb_array)
        else:
            self._heatmap_herb_visual = \
                self._ax_heatmap_herb.imshow(herb_array, interpolation='nearest',
                                             vmin=0, vmax=self.cmax_animals)
            plt.colorbar(self._heatmap_herb_visual, ax=self._ax_heatmap_herb,
                         orientation='horizontal')

    def _update_carnivore_heatmap(self, carn_array):
        """
        This function updates the heatmap of carnivores plot each time it is called. Shows the
        distribution of carnivores in the cells of the island.
        """
        if self._heatmap_carn_visual is not None:
            self._heatmap_carn_visual.set_data(carn_array)
        else:
            self._heatmap_carn_visual = \
                self._ax_heatmap_carn.imshow(carn_array, interpolation='nearest',
                                             vmin=0, vmax=self.cmax_animals)
            plt.colorbar(self._heatmap_carn_visual, ax=self._ax_heatmap_carn,
                         orientation='horizontal')

    def _update_everything(self, step):
        """
        Everytime the simulation has run another year, it calls this function which will update
        the plots in our figure. Adds a pause to make sure figure is visible before the next
        simulation is shown.
        """
        self._update_herbivore_heatmap(self._herb_array())
        self._update_carnivore_heatmap(self._carn_array())
        self._update_num_animals(step, self.num_animals_per_species['Herbivore'],
                                 self.num_animals_per_species['Carnivore'])
        self._update_fitness_graph()
        self._update_age_graph()
        self._update_weight_graph()
        self._txt.set_text('Year: {:5d}'.format(self._year + 1))
        plt.pause(1e-06)

    def _update_fitness_graph(self):
        """
        Update fitness distribution for both species by calling property_distribution() and setting
        the returned value as y data.
        """

        self._ax_fitness.set_ylim(0, self.num_animals/2)
        herb_count, carn_count, a, b, c, d = self.property_distribution()
        self.herb_f_hist.set_ydata(herb_count)
        self.carn_f_hist.set_ydata(carn_count)

    def _update_age_graph(self):
        """
        Update age distribution for both species by calling property_distribution() and setting
        the returned value as y data.
        """
        self._ax_age.set_ylim(0, self.num_animals/2)
        a, b, herb_count, carn_count, c, d = self.property_distribution()
        self.herb_a_hist.set_ydata(herb_count)
        self.carn_a_hist.set_ydata(carn_count)

    def _update_weight_graph(self):
        """
        Update weight distribution for both species by calling property_distribution() and setting
        the returned value as y data.
        """

        self._ax_weight.set_ylim(0, self.num_animals/2)
        a, b, c, d, herb_count, carn_count = self.property_distribution()
        self.herb_w_hist.set_ydata(herb_count)
        self.carn_w_hist.set_ydata(carn_count)

    def _save_visuals(self, img_years):
        """
        Everytime we want to save the figure as an image file in the simulation, we call this
        function. Function taken from lecture examples.
        """
        if self._img_base is None or self._year % img_years != 0:
            return

        plt.savefig('{base}_{num:05d}.{type}'.format(base=self._img_base,
                                                     num=self._img_counter,
                                                     type=self._img_fmt))
        self._img_counter += 1

    def make_movie(self):
        """
        Create MPEG4 movie from visualization images saved. Function taken from lecture examples.
        """
        if self._img_base is None:
            raise RuntimeError("No filename defined.")

        if self.movie_fmt == 'mp4':
            try:
                # Parameters chosen according to http://trac.ffmpeg.org/wiki/Encode/H.264,
                # section "Compatibility"
                subprocess.check_call([self._FFMPEG_BINARY,
                                       '-i', '{}_%05d.png'.format(self._img_base),
                                       '-y',
                                       '-profile:v', 'baseline',
                                       '-level', '3.0',
                                       '-pix_fmt', 'yuv420p',
                                       '{}.{}'.format(self._img_base, self.movie_fmt)])
            except subprocess.CalledProcessError as err:
                raise RuntimeError('ERROR: ffmpeg failed with: {}'.format(err))
        else:
            raise ValueError('Unknown movie format: ' + self.movie_fmt)

